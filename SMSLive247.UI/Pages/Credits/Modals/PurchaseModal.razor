@inject AuthenticationStateProvider auth
@inject Settings settings;
@inject IJSRuntime js

<Modal Title="Buy SMS Credits" @bind-Hidden="hideModal" VAlign="Modal.ModalVAlign.CENTER">
    <Body>
        @if (price != null)
        {
            <StaticText Label="SMS Quantity" Text="@price.Quantity.ToString("#,##0")" />
            <StaticText Label="Unit Price" Text="@(price.Price.ToString("₦ #,##0.00"))" />
            <StaticText Label="Purchase Amount" Text="@(price.Amount.ToString("₦ #,##0.00"))" />
            <StaticText Label="Transaction Fee" Text="@(price.Fee.ToString("₦ #,##0.00"))" />
            <StaticText Label="Total Amount" Text="@((price.Amount + price.Fee).ToString("₦ #,##0.00"))" />
        }
        else
        {
            <div class="alert alert-info" role="alert">
                Minimum SMS credit quantity to purchase is 500 sms credit.
            </div>
            <EditForm id="Purchase" Model="quantity" OnValidSubmit="ConfirmPrice">
                <DataAnnotationsValidator />
                <ValidationSummary />
                <FormField Label="Sms Quantity">
                    <InputNumber class="form-control" min="500" @bind-Value="quantity" required></InputNumber>
                </FormField>
            </EditForm>
        }
    </Body>
    <Footer>
        @if (price != null)
        {
            <Button Type="Button.Style.DEFAULT" @onclick="ConfirmPurchase">Pay with Paystack</Button>
            <Button Type="Button.Style.CANCEL" @onclick="CancelConfirmation">Cancel</Button>
        }
        else
        {
            <button form="Purchase" type="submit" class="btn btn-primary">Confirm Price</button>
        }
    </Footer>
</Modal>

@code {
    private bool hideModal = true;
    private PriceCalcResponse? price;
    private long quantity = 1000;

    // keep a reference so JS can call back into this instance
    private DotNetObjectReference<PurchaseModal>? dotNetRef;

    protected override async Task OnInitializedAsync()
    {
        var member = await ((Authentication.SmsAuthProvider)auth).GetMember();

        if (member == null)
            await alert.Error("Please re-login", "Error");
    }

    public void Show()
    {
        hideModal = false;
        StateHasChanged();
    }

    private void CancelConfirmation()
    {
        price = null;
    }

    private async Task ConfirmPrice()
    {
        try
        {
            var response = await apiClient.PriceCalculateAsync(null, quantity, "N");

            if (response.StatusCode == 200)
            {
                price = response.Result;
                return;
            }
            throw new Exception("apiClient.PurchaseBeginAsync() Failed");
        }
        catch (Exception ex)
        {
            await alert.Error(ex.Message, "Error");
        }
    }

    private async Task ConfirmPurchase()
    {
        try
        {
            if (price == null)
                throw new Exception("Confirm the price first");

            // Get the total amount including the transaction fee
            var totalAmount = (decimal)price.Amount + (decimal)price.Amount * 0.015M;

            // Paystack expects amount in Kobo, so multiply by 100 and cast to int/long.
            // Use Math.Round to handle potential floating point issues before casting.
            var totalAmountKobo = (long)Math.Round(totalAmount * 100M);

            var request = new PurchaseRequest { ProviderID = "PAYSTACK", Quantity = quantity };
            var response = await apiClient.PurchaseBeginAsync(request);

            if (response.StatusCode != 200)
                throw new Exception("apiClient.PurchaseBeginAsync() Failed");

            // Create a DotNetObjectReference to allow JS to call back into this component
            dotNetRef = DotNetObjectReference.Create(this);
            
            // Ensure access code is a string
            var accessCode = response.Result?.AccessCode?.ToString() ?? "";
            if (string.IsNullOrEmpty(accessCode))
                throw new Exception("No access code received from server");
                
            await js.InvokeVoidAsync("paystackPopup", accessCode, dotNetRef);
        }
        catch (Exception ex)
        {
            await alert.Error(ex.Message, "Error");
        }
        finally
        {
            // keep modal open until callback completes; only hide if you want
            hideModal = true;
        }
    }



    [JSInvokable("OnLoad")]
    public void OnLoad(string? info)
    {
        Console.WriteLine(info);
    }

    [JSInvokable("OnSuccess")]
    public async Task OnSuccess(string transactionReference)
    {
        try
        {
            await apiClient.PurchaseCompleteAsync(transactionReference);
        }
        catch (Exception ex)
        {
            await alert.Error(ex.Message, "Error");
        }
        finally
        {
            // dispose the DotNet reference after completion
            dotNetRef?.Dispose();
            dotNetRef = null;
        }
    }

    [JSInvokable("OnCancel")]
    public void OnCancel()
    {
        Console.WriteLine("canceled");
        dotNetRef?.Dispose();
        dotNetRef = null;
    }

    [JSInvokable("OnError")]
    public Task OnError(string errorMessage)
    {
        dotNetRef?.Dispose();
        dotNetRef = null;
        return alert.Error(errorMessage, "Error");
    }
}

<script src="https://js.paystack.co/v2/inline.js"></script>
<script>
    function paystackPopup(accessCode, dotNetRef) {
        const popup = new PaystackPop();

        function messageHandler(e) {
            try {
                if (!e.data) return;

                // Ensure it's from Paystack
                if (e.origin && !e.origin.includes('paystack')) return;

                const data = e.data;
                let safePayload = {};

                // Extract only safe serializable fields
                if (typeof data === 'object') {
                    safePayload = {
                        reference: data.reference || data.transaction || null,
                        message: data.message || null,
                        event: data.event || null,
                        status: data.status || null
                    };
                }

                // Route events properly
                if (safePayload.reference) {
                    dotNetRef?.invokeMethodAsync('OnSuccess', safePayload.reference);
                } else if (safePayload.message && safePayload.message.toLowerCase().includes('cancel')) {
                    dotNetRef?.invokeMethodAsync('OnCancel');
                } else if (safePayload.message) {
                    dotNetRef?.invokeMethodAsync('OnError', safePayload.message);
                } else {
                    dotNetRef?.invokeMethodAsync('OnLoad', JSON.stringify(safePayload));
                }
            } catch (err) {
                console.error('Handler error:', err);
            }
        }

        window.addEventListener('message', messageHandler);

        popup.resumeTransaction(accessCode);
    }

</script>
